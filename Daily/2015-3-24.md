### Setting Up Webpack with Rails

Rails原先就使用了[sprockets](https://github.com/sstephenson/sprockets)来加载js库，但随着对前端交互的要求日益增长，
sprockets使用统一压缩为一个文件的做法在部署是相当消耗时间，除此之外寻找代码之间的依赖关系也让人相当头疼。
于是我们将寻找更合适的技术来解决这个问题，最后发现webpack能够满足我们以下期待：
- 容易与rails集成
- 允许部分javascript还是通过sprockets引用
- 支持CommanJS模块定义

#### Modular JavaScript

首先看一下我们怎么通过webpack添加依赖:

1、
```
  // 在application.js
  require(‘./init.js’)
```
2、
```
  // 在init.js
  var HomeView = require(‘./views/home_view.js’),
  CurrentUserModel = require(‘./models/current_user_model.js’);
  // ... we render our Backbone view onto the page, passing in the model.
```
3、在home_view和current_user_model中又可以各自添加依赖，webpack会递归地找到所有的依赖，并且将他们串联起来作为一个bundle，
这样所得到的代码已经是按照顺序加载的。

4、如果在required的文件里设置`module.exports`, 则会将它包装在一个匿名函数中，并将该匿名函数存储到一个无序数组中。
当内容需要加载时则通过他们在数组中对应的序号添加，而不是通过他们所在的文件名。

5、一旦其中一个函数被调用，该函数就会被标识为”loaded”，而且缓存起来以用作下次引用。

6、下面是举个bundled version工作的例子：
```
/**
 * In this simplified example,
 * '_application.js' is our entry point
 * and it requires 'init.js',
 * which in turn requires both the 'home_view'
 * and the 'current_user_model'
 */

var modules = [
  // dependencies can be referenced by index
  function() {
    //... contents of ‘_application.js’ 
  },
  function() {
    //... contents of ‘init.js’ 
  },
  function() {
    //... contents of ./views/home_view.js’
  },
  function() {
    //... contents of ./models/current_user_model.js’
  },
];

// This function gets called right away
// with the modules above as a parameter.
(function(modules) {
  // The module cache
  var installedModules = {};

  // The require function
  function __webpack_require__(moduleId) {
    // Check if module is in cache
    if(installedModules[moduleId])
      return installedModules[moduleId].exports;

    // If the module isn't in the cache -
    // Create a new module (and put it into the cache)
    var module = installedModules[moduleId] = {
      exports: {},
      id: moduleId,
      loaded: false
    };

    // Execute the module function
    // Meaning the method at index 'moduleId'
    // in the 'modules' array gets called
    // with access to the 'module', 'module.exports',
    // and using '__webpack_require__'
    // wherever your script called 'require'
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    // Flag the module as loaded
    module.loaded = true;

    // Return the exports of the module
    return module.exports;
  };

  // ...

  // Load entry module and return exports
  // Meaning this will run '__webpack_require__'
  // with index 0 of the modules array
  return __webpack_require__(0);
})(modules);
```
7、附录

模块化的好处：
- 局部加载依赖
- 保持Global Scope干净

相关工具：
- [Browserify](http://browserify.org/)
- [RequireJS](http://requirejs.org/)
- [webpack](http://webpack.github.io/)

模块加载的风格：
- [CommonJS](http://wiki.commonjs.org/wiki/Modules)
- [AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md)

#### Setting up webpack

1. `npm install webpack -save`
2. 配置webpack.config，输出javascript到我们期待的位置。
```
/**
 * @see http://webpack.github.io/docs/configuration.html
 * for webpack configuration options
 */
module.exports = {
  // 'context' sets the directory where webpack looks for module files you list in
  // your 'require' statements
  context: __dirname + '/app/assets/javascripts',

  // 'entry' specifies the entry point, where webpack starts reading all
  // dependencies listed and bundling them into the output file.
  // The entrypoint can be anywhere and named anything - here we are calling it
  // '_application' and storing it in the 'javascripts' directory to follow
  // Rails conventions.
  entry: './app/assets/javascripts/_application.js',

  // 'output' specifies the filepath for saving the bundled output generated by
  // wepback.
  // It is an object with options, and you can interpolate the name of the entry
  // file using '[name]' in the filename.
  // You will want to add the bundled filename to your '.gitignore'.
  output: {
    filename: '[name].bundle.js',
    // We want to save the bundle in the same directory as the other JS.
    path: __dirname + '/app/assets/javascripts',
  },

  // The 'module' and 'loaders' options tell webpack to use loaders.
  // @see http://webpack.github.io/docs/using-loaders.html
  module: {
    loaders: [
      {
        // Pattern to match only files with the '.js' or '.jsx' extension.
        // This tells the loader to only run for those files.
        test: /\.jsx?$/,
        // @see https://github.com/shama/es6-loader
        // It was installed with 'npm install es6-loader --save' and transpiles
        // es6 to es5.
        loader: 'es6-loader'
      }
    ]
  }
};
```

#### Integrating Webpack With Rails

由于我们集合使用了sprockets和webpack，因此build的步骤有点多：

1、webpack先compile成bundle

2、然后引入bundle到rails项目中去
```
// app/assets/javascripts/application.js
require_tree . => require main.bundle
```
3、这样rails就会使用sprockets去压缩bundle后的js代码

#### Developing with Webpack

喵了个咪，你肯定发现了我们每次js改动后都需要用webpack来生成bundle，
这岂不是重复工作？！幸亏webpack提供了“[watch mode](http://webpack.github.io/docs/cli.html#watch-mode-watch)”，
会监测js文件修改，自动重新compile。更偷懒的话还可以通过[foreman](https://github.com/ddollar/foreman)
将相关的进程绑定到同一命令去，比如`rails s`

#### Using Loaders With Webpack

[Loader](http://webpack.github.io/docs/loaders.html)是个好东西，可以在加载js文件时，先执行Loader，
Loader的[种类](http://webpack.github.io/docs/list-of-loaders.html)相当丰富，比如Coffee转js，coffee-jsx, typescript等等……
任何人都可以自己写一个Loader，因为Loader本来就是一个module。

这里介绍一个给力的Loader，[es6-loader](https://github.com/shama/es6-loader)，它允许我们使用所有es6的特性，
然后转译成所有浏览器支持的js版本！ 比如说，
```
// ES6 syntax
postsCollection.each((post) => {
 if (post.get('highlighted')) {
 this.highlightedPosts.push(post);
 }
});


// The translated version output by webpack
var this$0 = this;
postsCollection.each(function(post) {
 if (post.get('highlighted')) {
 this$0.highlightedPosts.push(post);
 }
});
```

#### Gotchas

呵呵，你以为我没想过完全替代sprockets，直接用webpack吗？我是舍不得一些现成的js gem呀！
比如说[js-routes](https://github.com/railsware/js-routes)！

#### Choose Wisely

做技术选型就是在各个技术中取平衡折中的方案。花一些时间来研究和尝试新工具是否合适新项目还是蛮值得的。
这里将相应的[demo](https://github.com/flarnie/webpack_rails_demo)贡献出来，希望对大家有所帮助！

[原文链接](https://medium.com/brigade-engineering/setting-up-webpack-with-rails-c62aea149679)

-----

下面为一些杂记：

1. 调研现在的flux框架，选取一个用作前端框架
  - [reflux](https://github.com/spoike/refluxjs) -- 2001 star
  - [fluxxor](https://github.com/BinaryMuse/fluxxor) -- 1042 star
  - [mcfly](https://github.com/kenwheeler/mcfly) -- 635 star
  - [delorean](https://github.com/deloreanjs/delorean) --580 star
  - [fluxy](https://github.com/jmreidy/fluxy) -- 219 star
  - [barracks](https://github.com/yoshuawuyts/barracks) -- 56 star
  - [iflux](https://github.com/hufeng/iflux) -- 3 star
  - [这里](https://github.com/kriasoft/react-starter-kit/issues/22)有个集合可以参考。
2. 调研实时ruby框架
  - [angelo](https://github.com/kenichi/angelo) -- 221 star
  - [private_pub](https://github.com/ryanb/private_pub) -- 757 star
  - [websocket-rails](https://github.com/websocket-rails/websocket-rails) -- 1130 star


-----

我总算是对随页面的交互复杂度提高而带来的DOM操作超繁琐的操作有个概念了：

举个栗子，比如看起来很简单地添加标签，删除标签，修改标签，加上自动匹配输入，竟然在修改标签这步上要对DOM操作得要死。讲下交互：

1. 点击原标签
2. 显示输入框
3. 输入时自动匹配提示
4. 输入完成删除输入框
5. 插入新标签到原来的位置

如果用React的话，只需要前三步，然后数据提交之后，React自动渲染DOM，无需我们手动再删除旧标签再插入新标签。

-----

我们在前端布局时经常会遇到固定的宽度，然后字体内容太长以致不能完全显示的情况。
一般这种情况都把超出的内容截断，然后显示“...”，然后用户鼠标hover上去时再显示完整内容。
那代码怎么实现呢？

首先是内容截断：
```
  // css
  width: 100px; // 比如固定宽度为100px
  overflow: hidden; // 超出的部分隐藏
  text-overflow: ellipsis; // 显示”...”
  white-space: nowrap; // 遇到空格不换行
```
然后是hover显示完成内容
```
  // html
  <p title=”#{content}”>#{content}</p> // content为需要显示的内容
```
伟大的title属性已经满足这个需求……当然想要换种popup的样式的话就需要另外写了……

-----

ORZ..这篇til又写了一个星期，主要是rails配置webpack的部分花费的时间比较多。
又懒得新开一篇来写，怎么随手怎么写，都快变周记了……
